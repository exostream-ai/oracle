/**
 * Oracle state initialization and management for Cloudflare Worker
 * Extracted from worker.ts to enable modular route/middleware structure
 */

import type { GreekSheet, ForwardPrice, OracleState, ContextTier } from '../core/types.js';
import { computeThetaFromHistory, FAMILY_LINEAGE as familyLineage } from '../core/constants.js';
import providers from '../../seed/providers.json';
import families from '../../seed/families.json';
import models from '../../seed/models.json';
import historicalPrices from '../../seed/historical_prices.json';
import type { SeedModel, SeedFamily, SeedProvider, SeedPrice } from './worker-types.js';

// Try importing pre-computed oracle state (generated by build:oracle)
// This may not exist during local dev - fallback handles that case
let precomputedOracleState: any = null;
try {
  // @ts-ignore - generated at build time, may not exist in dev
  precomputedOracleState = require('./oracle-state.json');
} catch {
  // Pre-computed state not available, will use seed JSON parsing fallback
}

// Module-scope state variables (mutable, exported)
export let oracleState: OracleState;
export let tickerIndex: Map<string, GreekSheet>;
export let modelContextTiers: Map<string, ContextTier[]>;

// Re-export seed data for route handlers
export { familyLineage, historicalPrices };
export const seedModels = models;

/**
 * Generate a cryptographically secure API key
 */
export function generateApiKey(): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const segments = [];
  const randomBytes = new Uint8Array(32);
  crypto.getRandomValues(randomBytes);
  let byteIdx = 0;
  for (let s = 0; s < 4; s++) {
    let segment = '';
    for (let i = 0; i < 8; i++) {
      segment += chars[randomBytes[byteIdx++] % chars.length];
    }
    segments.push(segment);
  }
  return `exo_${segments.join('_')}`;
}

/**
 * Load pre-computed oracle state from oracle-state.json
 * Reconstructs Maps from serialized JSON format
 * Throws if data is invalid, triggering fallback to buildOracleState()
 */
function loadPrecomputedState(): OracleState {
  if (!precomputedOracleState) {
    throw new Error('Pre-computed state not available');
  }

  // Validate required fields
  if (!precomputedOracleState.version || !precomputedOracleState.generated_at) {
    throw new Error('Invalid pre-computed state: missing version or generated_at');
  }

  // Reconstruct models Map from array
  const modelsMap = new Map<string, GreekSheet>();
  for (const model of precomputedOracleState.models) {
    modelsMap.set(model.modelId, model);
  }

  // Reconstruct forwardCurves Map from object
  const forwardCurvesMap = new Map<string, ForwardPrice[]>();
  for (const [key, curves] of Object.entries(precomputedOracleState.forwardCurves)) {
    // Add computedAt Date field (not serialized in JSON)
    const curvesWithDate = (curves as any[]).map(c => ({
      ...c,
      computedAt: new Date(precomputedOracleState.generated_at),
    }));
    forwardCurvesMap.set(key, curvesWithDate);
  }

  return {
    models: modelsMap,
    forwardCurves: forwardCurvesMap,
    lastUpdate: new Date(precomputedOracleState.generated_at),
    cacheAgeSeconds: Math.floor((Date.now() - new Date(precomputedOracleState.generated_at).getTime()) / 1000),
  };
}

/**
 * Build oracle state from seed data (internal helper)
 * Fallback when pre-computed state is not available
 */
function buildOracleState(): OracleState {
  const providerMap = new Map((providers as SeedProvider[]).map(p => [p.provider_id, p]));
  const familyMap = new Map((families as SeedFamily[]).map(f => [f.family_id, f]));
  const prices = historicalPrices as SeedPrice[];

  const latestPrices = new Map<string, { beta: number; date: Date }>();
  for (const price of prices) {
    const key = `${price.model_id}:${price.price_type}`;
    const priceDate = new Date(price.observed_at);
    const existing = latestPrices.get(key);
    if (!existing || priceDate > existing.date) {
      latestPrices.set(key, { beta: price.beta, date: priceDate });
    }
  }

  const modelsMap = new Map<string, GreekSheet>();
  const seedContextTiers = new Map<string, ContextTier[]>();

  for (const model of models as SeedModel[]) {
    const family = familyMap.get(model.family_id);
    if (!family) continue;

    const provider = providerMap.get(family.provider_id);
    const syncPrice = latestPrices.get(`${model.model_id}:sync`);
    const batchPrice = latestPrices.get(`${model.model_id}:batch`);
    const { theta, sigma } = computeThetaFromHistory(prices, model.family_id);

    if (model.tiers && model.tiers.length > 0) {
      seedContextTiers.set(model.model_id, model.tiers.map(t => ({
        tauStart: t.tau_start,
        tauEnd: t.tau_end,
        alpha: t.alpha,
      })));
    }

    // Expose tiers to module scope for pricing endpoints
    modelContextTiers = seedContextTiers;

    modelsMap.set(model.model_id, {
      modelId: model.model_id,
      displayName: model.display_name,
      tickerSync: model.ticker_sync,
      tickerBatch: model.ticker_batch ?? undefined,
      providerName: provider?.display_name ?? family.provider_id,
      contextWindow: model.context_window,
      rIn: family.r_in,
      rCache: family.r_cache,
      rThink: family.r_think ?? undefined,
      rBatch: family.r_batch ?? undefined,
      isReasoning: family.is_reasoning,
      betaSync: syncPrice?.beta,
      betaBatch: batchPrice?.beta,
      theta,
      sigma,
    });
  }

  // Build forward curves
  const forwardCurves = new Map<string, ForwardPrice[]>();
  const tenors = ['1M', '3M', '6M'] as const;
  const tenorMonths: Record<string, number> = { '1M': 1, '3M': 3, '6M': 6 };

  for (const [modelId, model] of modelsMap) {
    if (!model.betaSync || !model.theta) continue;

    const theta = model.theta;
    const forwards: ForwardPrice[] = [];

    for (const tenor of tenors) {
      const t = tenorMonths[tenor];
      const decayFactor = Math.exp(-theta * t);
      forwards.push({
        modelId,
        priceType: 'sync',
        tenor,
        betaSpot: model.betaSync,
        thetaUsed: theta,
        betaForward: model.betaSync * decayFactor,
        decayFactor,
        computedAt: new Date(),
      });
    }

    forwardCurves.set(`${modelId}:sync`, forwards);
  }

  return {
    models: modelsMap,
    forwardCurves,
    lastUpdate: new Date(),
    cacheAgeSeconds: 0,
  };
}

/**
 * Initialize oracle state at module load (cold start)
 * Tries to load pre-computed state first, falls back to building from seed data
 */
export function initializeOracleState() {
  try {
    // Try loading pre-computed state first (fast path)
    oracleState = loadPrecomputedState();
  } catch {
    // Fallback to building from seed JSON (current behavior)
    oracleState = buildOracleState();
  }

  // Build ticker index regardless of source
  tickerIndex = new Map();
  for (const model of oracleState.models.values()) {
    tickerIndex.set(model.tickerSync.toUpperCase(), model);
  }

  // Reconstruct modelContextTiers from pre-computed state or seed models
  if (precomputedOracleState?.contextTiers) {
    const tiersMap = new Map<string, ContextTier[]>();
    for (const [modelId, tiers] of Object.entries(precomputedOracleState.contextTiers)) {
      tiersMap.set(modelId, tiers as ContextTier[]);
    }
    modelContextTiers = tiersMap;
  }
}

// Initialize at module load (cold start)
initializeOracleState();
